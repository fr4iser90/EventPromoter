{
  "name": "Multi-Platform Social Media Publisher",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "multiplatform-publisher",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "db1cb1a8-09b5-b190-4903-8a112cff091b",
      "name": "Interface Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        200,
        200
      ],
      "webhookId": "interface-webhook"
    },
    {
      "parameters": {
        "formTitle": "Neues Event erstellen",
        "formDescription": "FÃ¼lle alle Felder aus fÃ¼r die automatische VerÃ¶ffentlichung auf Social Media",
        "options": {
          "formElements": [
            {
              "fieldLabel": "Event Titel",
              "fieldName": "eventTitle",
              "fieldType": "text",
              "requiredField": true,
              "placeholder": "z.B. Berghain Techno Night"
            },
            {
              "fieldLabel": "Datum",
              "fieldName": "eventDate",
              "fieldType": "date",
              "requiredField": true
            },
            {
              "fieldLabel": "Uhrzeit",
              "fieldName": "eventTime",
              "fieldType": "text",
              "placeholder": "22:00",
              "requiredField": false
            },
            {
              "fieldLabel": "Veranstaltungsort",
              "fieldName": "venue",
              "fieldType": "text",
              "requiredField": true,
              "placeholder": "z.B. Berghain"
            },
            {
              "fieldLabel": "Stadt",
              "fieldName": "city",
              "fieldType": "text",
              "requiredField": true,
              "placeholder": "z.B. Berlin"
            },
            {
              "fieldLabel": "Beschreibung",
              "fieldName": "description",
              "fieldType": "textarea",
              "requiredField": false,
              "placeholder": "ErzÃ¤hl etwas Ã¼ber das Event..."
            },
            {
              "fieldLabel": "Bild-URL",
              "fieldName": "imageUrl",
              "fieldType": "text",
              "requiredField": false,
              "placeholder": "https://example.com/image.jpg"
            },
            {
              "fieldLabel": "Ticket-URL",
              "fieldName": "ticketUrl",
              "fieldType": "text",
              "requiredField": false,
              "placeholder": "https://tickets.example.com"
            },
            {
              "fieldLabel": "Email-EmpfÃ¤nger",
              "fieldName": "emailRecipient",
              "fieldType": "text",
              "requiredField": true,
              "placeholder": "deine@email.com"
            }
          ]
        }
      },
      "id": "2f08c34e-7bd4-f408-424d-92227372bb92",
      "name": "On form submission",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -1260,
        -1020
      ]
    },
    {
      "parameters": {},
      "id": "ea301d6b-af9d-d8d8-48c3-9743977a93a1",
      "name": "ğŸ“ Manual File Path Input",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1260,
        -1220
      ]
    },
    {
      "parameters": {
        "operation": "read",
        "fileSelector": "={{ $json.filePath }}",
        "options": {}
      },
      "id": "8f373439-4051-c8bd-4a4f-b129018dd32c",
      "name": "ğŸ“„ Read File from Path",
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        -1040,
        -1220
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Parse manual input - detect markdown or images\n// DE: Manuelle Eingabe parsen - Markdown oder Bilder erkennen\n\nconst item = $input.item.json;\n\n// Check if input is markdown or just text\nlet content = item.content || item.text || '';\n\n// Detect if content is an image URL\nconst imageUrlRegex = /(https?:\\/\\/.*\\.(?:png|jpg|jpeg|gif|webp|svg))/i;\nconst imageMatch = content.match(imageUrlRegex);\n\n// Detect if content is markdown\nconst isMarkdown = content.includes('#') || content.includes('*') || content.includes('[') || content.includes('![');\n\nlet parsedData = {};\n\nif (imageMatch && content.trim() === imageMatch[0]) {\n  // Content is JUST an image URL\n  parsedData = {\n    eventTitle: \"Quick Image Post\",\n    eventDate: new Date().toISOString().split('T')[0], // Today's date\n    eventTime: \"12:00\",\n    venue: \"Online\",\n    city: \"Digital\",\n    description: \"Shared image\",\n    imageUrl: imageMatch[0],\n    ticketUrl: \"\",\n    emailRecipient: \"default@email.com\",\n    publishTo: {\n      twitter: true,\n      instagram: true,\n      facebook: false,\n      linkedin: false,\n      reddit: false,\n      email: false\n    },\n    emailRecipients: [\"default@email.com\"],\n    source: 'manual-image'\n  };\n} else if (isMarkdown) {\n  // Parse markdown content\n  // Simple markdown parser for event data\n  const lines = content.split('\\n');\n  let title = '';\n  let date = '';\n  let time = '22:00';\n  let venue = '';\n  let city = '';\n  let description = '';\n  let imageUrl = '';\n  let ticketUrl = '';\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed.startsWith('# ')) {\n      title = trimmed.substring(2).trim();\n    } else if (trimmed.includes('Date:') || trimmed.includes('Datum:')) {\n      date = trimmed.split(':')[1]?.trim() || '';\n    } else if (trimmed.includes('Time:') || trimmed.includes('Uhrzeit:')) {\n      time = trimmed.split(':')[1]?.trim() || '22:00';\n    } else if (trimmed.includes('Venue:') || trimmed.includes('Ort:')) {\n      venue = trimmed.split(':')[1]?.trim() || '';\n    } else if (trimmed.includes('City:') || trimmed.includes('Stadt:')) {\n      city = trimmed.split(':')[1]?.trim() || '';\n    } else if (trimmed.includes('Image:') || trimmed.includes('Bild:')) {\n      imageUrl = trimmed.split(':')[1]?.trim() || '';\n    } else if (trimmed.includes('Tickets:') || trimmed.includes('Tickets:')) {\n      ticketUrl = trimmed.split(':')[1]?.trim() || '';\n    } else if (trimmed && !trimmed.startsWith('#') && !trimmed.includes(':')) {\n      description += trimmed + ' ';\n    }\n  }\n\n  parsedData = {\n    eventTitle: title || \"Manual Event Post\",\n    eventDate: date || new Date().toISOString().split('T')[0],\n    eventTime: time,\n    venue: venue || \"TBA\",\n    city: city || \"TBA\",\n    description: description.trim() || \"Event description\",\n    imageUrl: imageUrl,\n    ticketUrl: ticketUrl,\n    emailRecipient: \"default@email.com\",\n    publishTo: {\n      twitter: true,\n      instagram: true,\n      facebook: false,\n      linkedin: false,\n      reddit: false,\n      email: false\n    },\n    emailRecipients: [\"default@email.com\"],\n    source: 'manual-markdown'\n  };\n} else {\n  // Plain text - treat as description\n  parsedData = {\n    eventTitle: \"Quick Text Post\",\n    eventDate: new Date().toISOString().split('T')[0],\n    eventTime: \"12:00\",\n    venue: \"Online\",\n    city: \"Digital\",\n    description: content,\n    imageUrl: \"\",\n    ticketUrl: \"\",\n    emailRecipient: \"default@email.com\",\n    publishTo: {\n      twitter: true,\n      instagram: false,\n      facebook: false,\n      linkedin: false,\n      reddit: false,\n      email: false\n    },\n    emailRecipients: [\"default@email.com\"],\n    source: 'manual-text'\n  };\n}\n\nreturn [{\n  json: parsedData\n}];\n"
      },
      "id": "4362bd96-78ab-b408-41e7-a174e39d6ba3",
      "name": "ğŸ” Parse Manual Input (Markdown/Image)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -840,
        -1220
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/upload-event",
        "options": {
          "formData": true
        }
      },
      "id": "e4f25b0a-eee9-3d5d-4207-b3d68a4cb86f",
      "name": "ğŸ“ File Upload (PDF/PNG/JPG)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1280,
        -600
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dj-event",
        "responseMode": "responseNode"
      },
      "id": "db1cb1a8-09b5-b190-4903-8a112cff091b",
      "name": "ğŸ“¥ Webhook Trigger (API)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -1280,
        -800
      ],
      "webhookId": "dj-event-webhook"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems"
      },
      "id": "0b96c802-0f57-4ef6-4700-89c6caae9042",
      "name": "âœ… Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1720,
        -940
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Validate and prepare input data\n// DE: Eingabedaten validieren und vorbereiten\nconst item = $input.item.json;\n\n// Check if this is interface data or form data / PrÃ¼fen ob Interface- oder Form-Daten\nconst isInterfaceData = item.files && Array.isArray(item.files);\n\n// Interface data validation / Interface-Daten validierung\nif (isInterfaceData) {\n  // Required fields for interface data\n  if (!item.files || item.files.length === 0) {\n    throw new Error('No files provided');\n  }\n  if (!item.publishTo || Object.keys(item.publishTo).length === 0) {\n    throw new Error('No platforms selected for publishing');\n  }\n\n  // Create content from files and hashtags / Inhalt aus Dateien und Hashtags erstellen\n  const imageFiles = item.files.filter(f => f.isImage);\n  const textFiles = item.files.filter(f => !f.isImage);\n\n  // Use first text file as main content or create from hashtags\n  let eventTitle = 'Multi-Platform Post';\n  let description = '';\n\n  if (textFiles.length > 0) {\n    // Try to extract title from first text file\n    const firstTextFile = textFiles[0];\n    const contentLines = Buffer.from(firstTextFile.base64, 'base64').toString().split('\\n');\n    eventTitle = contentLines[0]?.trim() || 'Multi-Platform Post';\n    description = contentLines.slice(1).join('\\n').trim();\n  }\n\n  // Add hashtags to description\n  if (item.hashtags && item.hashtags.length > 0) {\n    description += '\\n\\n' + item.hashtags.join(' ');\n  }\n\n  // Prepare output for interface data / Ausgabe fÃ¼r Interface-Daten vorbereiten\n  return [{\n    json: {\n      eventTitle: eventTitle,\n      eventDate: new Date().toISOString().split('T')[0], // Today's date\n      eventTime: new Date().toTimeString().slice(0,5), // Current time\n      formattedDate: new Date().toLocaleDateString('de-DE', {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      }),\n      venue: 'Online',\n      city: 'Web',\n      description: description,\n      imageUrl: imageFiles.length > 0 ? `data:${imageFiles[0].type};base64,${imageFiles[0].base64}` : '',\n      ticketUrl: '',\n      publishTo: item.publishTo,\n      emailRecipients: [],\n      redditSubreddit: item.platformSettings?.reddit?.subreddit || '',\n      redditFlair: item.platformSettings?.reddit?.flair || '',\n      redditNsfw: false,\n      redditSpoiler: false,\n      redditPostType: 'text',\n      // Interface-specific data\n      interfaceData: {\n        files: item.files,\n        hashtags: item.hashtags || [],\n        platformSettings: item.platformSettings || {},\n        metadata: item.metadata || {}\n      },\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Form data validation / Form-Daten validierung\nconst requiredFields = ['eventTitle', 'eventDate', 'venue', 'city'];\nconst missingFields = requiredFields.filter(field => !item[field]);\n\nif (missingFields.length > 0) {\n  throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n}\n\n// Set defaults / Standardwerte setzen\nconst publishTo = item.publishTo || {\n  twitter: true,\n  instagram: true,\n  facebook: true,\n  linkedin: false,\n  reddit: false,\n  email: false\n};\n\n// Format date / Datum formatieren\nlet formattedDate = item.eventDate;\nif (item.eventDate && item.eventTime) {\n  const date = new Date(`${item.eventDate}T${item.eventTime}`);\n  formattedDate = date.toLocaleDateString('de-DE', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  });\n}\n\n// Prepare output / Ausgabe vorbereiten\nreturn [{\n  json: {\n    eventTitle: item.eventTitle,\n    eventDate: item.eventDate,\n    eventTime: item.eventTime || '22:00',\n    formattedDate: formattedDate,\n    venue: item.venue,\n    city: item.city,\n    description: item.description || '',\n    imageUrl: item.imageUrl || '',\n    ticketUrl: item.ticketUrl || '',\n    publishTo: publishTo,\n    emailRecipients: item.emailRecipients || [],\n    // Reddit-specific fields / Reddit-spezifische Felder\n    redditSubreddit: item.redditSubreddit || '',\n    redditFlair: item.redditFlair || '',\n    redditNsfw: item.redditNsfw || false,\n    redditSpoiler: item.redditSpoiler || false,\n    redditPostType: item.redditPostType || 'text', // 'text' or 'link'\n    timestamp: new Date().toISOString()\n  }\n}];\n"
      },
      "id": "0ae3ea30-45b9-78f7-4809-8dc561e5914a",
      "name": "ğŸ” Validate & Prepare Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -920
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Validate platform credentials and requirements\n// DE: Plattform-Credentials und Anforderungen validieren\n\nconst item = $input.item.json;\n\n// Platform validation rules\nconst platformRules = {\n  twitter: {\n    required: ['eventTitle'],\n    maxLength: 280,\n    supports: ['text']\n  },\n  instagram: {\n    required: ['eventTitle', 'imageUrl'],\n    maxLength: 2200,\n    supports: ['image', 'text']\n  },\n  facebook: {\n    required: ['eventTitle'],\n    maxLength: null, // No strict limit\n    supports: ['text', 'image']\n  },\n  linkedin: {\n    required: ['eventTitle'],\n    maxLength: 3000,\n    supports: ['text', 'image']\n  },\n  reddit: {\n    required: ['eventTitle', 'redditSubreddit'],\n    maxLength: null,\n    supports: ['text', 'image']\n  },\n  email: {\n    required: ['eventTitle', 'emailRecipients'],\n    maxLength: null,\n    supports: ['text', 'image', 'html']\n  }\n};\n\nconst validationResults = [];\nlet hasErrors = false;\n\n// Check each enabled platform\nfor (const [platform, enabled] of Object.entries(item.publishTo || {})) {\n  if (!enabled) continue;\n\n  const rules = platformRules[platform];\n  if (!rules) {\n    validationResults.push({\n      platform,\n      valid: false,\n      error: `Unknown platform: ${platform}`\n    });\n    hasErrors = true;\n    continue;\n  }\n\n  // Check required fields\n  const missingFields = rules.required.filter(field => !item[field]);\n  if (missingFields.length > 0) {\n    validationResults.push({\n      platform,\n      valid: false,\n      error: `Missing required fields: ${missingFields.join(', ')}`\n    });\n    hasErrors = true;\n    continue;\n  }\n\n  // Check content length if applicable\n  if (rules.maxLength && item[`${platform}Text`] && item[`${platform}Text`].length > rules.maxLength) {\n    validationResults.push({\n      platform,\n      valid: false,\n      error: `Content too long: ${item[`${platform}Text`].length} > ${rules.maxLength} characters`\n    });\n    hasErrors = true;\n    continue;\n  }\n\n  // Platform-specific validations\n  if (platform === 'reddit' && !item.redditSubreddit) {\n    validationResults.push({\n      platform,\n      valid: false,\n      error: 'Reddit subreddit is required'\n    });\n    hasErrors = true;\n    continue;\n  }\n\n  if (platform === 'email' && (!item.emailRecipients || item.emailRecipients.length === 0)) {\n    validationResults.push({\n      platform,\n      valid: false,\n      error: 'Email recipients are required'\n    });\n    hasErrors = true;\n    continue;\n  }\n\n  validationResults.push({\n    platform,\n    valid: true,\n    supports: rules.supports\n  });\n}\n\nif (hasErrors) {\n  throw new Error(`Platform validation failed:\\n${validationResults\n    .filter(r => !r.valid)\n    .map(r => `${r.platform}: ${r.error}`)\n    .join('\\n')}`);\n}\n\nreturn [{\n  json: {\n    ...item,\n    platformValidation: validationResults,\n    validationPassed: true,\n    validatedAt: new Date().toISOString()\n  }\n}];\n"
      },
      "id": "10afe4e3-b742-b089-4619-818ca21249b4",
      "name": "âœ… Validate Platforms",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -360,
        -920
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Validate image and ticket URLs\n// DE: Bild- und Ticket-URLs validieren\n\nconst item = $input.item.json;\nconst axios = require('axios');\n\nasync function validateUrl(url, timeout = 5000) {\n  if (!url) return { valid: true, reachable: false }; // Optional URL\n\n  try {\n    // Basic URL format validation\n    new URL(url);\n\n    // Try to reach the URL (HEAD request for efficiency)\n    const response = await axios.head(url, {\n      timeout,\n      headers: {\n        'User-Agent': 'n8n-workflow/1.0 (URL Validation)'\n      }\n    });\n\n    return {\n      valid: true,\n      reachable: response.status >= 200 && response.status < 400,\n      statusCode: response.status,\n      contentType: response.headers['content-type']\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      reachable: false,\n      error: error.message,\n      reason: error.code || 'Unknown error'\n    };\n  }\n}\n\nasync function main() {\n  const results = {};\n\n  // Validate image URL\n  if (item.imageUrl) {\n    console.log(`ğŸ” Validating image URL: ${item.imageUrl}`);\n    results.imageUrl = await validateUrl(item.imageUrl);\n\n    if (results.imageUrl.valid && results.imageUrl.reachable) {\n      // Check if it's actually an image\n      const contentType = results.imageUrl.contentType;\n      if (contentType && !contentType.startsWith('image/')) {\n        results.imageUrl.warning = `URL does not point to an image (Content-Type: ${contentType})`;\n      }\n    }\n  }\n\n  // Validate ticket URL\n  if (item.ticketUrl) {\n    console.log(`ğŸ” Validating ticket URL: ${item.ticketUrl}`);\n    results.ticketUrl = await validateUrl(item.ticketUrl);\n  }\n\n  // Check for validation errors\n  const imageError = results.imageUrl && !results.imageUrl.valid;\n  const ticketError = results.ticketUrl && !results.ticketUrl.valid;\n\n  if (imageError || ticketError) {\n    const errors = [];\n    if (imageError) errors.push(`Image URL: ${results.imageUrl.error}`);\n    if (ticketError) errors.push(`Ticket URL: ${results.ticketUrl.error}`);\n\n    throw new Error(`URL validation failed:\\n${errors.join('\\n')}`);\n  }\n\n  // Log warnings\n  if (results.imageUrl?.warning) {\n    console.warn(`âš ï¸  ${results.imageUrl.warning}`);\n  }\n\n  return [{\n    json: {\n      ...item,\n      urlValidation: results,\n      urlsValidated: true,\n      validatedAt: new Date().toISOString()\n    }\n  }];\n}\n\nreturn main();\n"
      },
      "id": "418f0b72-98dc-06e0-4ee0-a8e012ade0c9",
      "name": "ğŸ”— Validate URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -140,
        -920
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Format content for different platforms\n// DE: Content fÃ¼r verschiedene Plattformen formatieren\nconst item = $input.item.json;\n\n// Base text / Basistext\nconst baseText = `${item.eventTitle}\\n\\nğŸ“… ${item.formattedDate}\\nğŸ• ${item.eventTime}\\nğŸ“ ${item.venue}, ${item.city}\\n\\n${item.description || ''}`.trim();\n\n// Twitter/X format (280 chars max) / Twitter/X Format (max. 280 Zeichen)\nlet twitterText = baseText;\nif (item.ticketUrl) {\n  twitterText += `\\n\\nğŸ« Tickets: ${item.ticketUrl}`;\n}\n// Truncate if too long / KÃ¼rzen falls zu lang\nif (twitterText.length > 280) {\n  twitterText = twitterText.substring(0, 277) + '...';\n}\n\n// Instagram format (2200 chars max, supports emojis) / Instagram Format (max. 2200 Zeichen)\nlet instagramText = `${item.eventTitle}\\n\\nğŸ“… ${item.formattedDate}\\nğŸ• ${item.eventTime}\\nğŸ“ ${item.venue}, ${item.city}\\n\\n${item.description || ''}`;\nif (item.ticketUrl) {\n  instagramText += `\\n\\nğŸ« Link in Bio oder: ${item.ticketUrl}`;\n}\ninstagramText += `\\n\\n#DJ #Event #${item.city.replace(/\\s/g, '')} #Nightlife`;\n\n// Facebook format / Facebook Format\nlet facebookText = `${item.eventTitle}\\n\\nğŸ“… ${item.formattedDate}\\nğŸ• ${item.eventTime}\\nğŸ“ ${item.venue}, ${item.city}\\n\\n${item.description || ''}`;\nif (item.ticketUrl) {\n  facebookText += `\\n\\nğŸ« Tickets: ${item.ticketUrl}`;\n}\n\n// LinkedIn format (professional tone) / LinkedIn Format (professioneller Ton)\nlet linkedinText = `ğŸ§ ${item.eventTitle}\\n\\nğŸ“… Date: ${item.formattedDate}\\nğŸ• Time: ${item.eventTime}\\nğŸ“ Location: ${item.venue}, ${item.city}\\n\\n${item.description || 'Join us for an amazing night!'}`;\nif (item.ticketUrl) {\n  linkedinText += `\\n\\nğŸ« Get your tickets: ${item.ticketUrl}`;\n}\n\n// Reddit format (Markdown supported) / Reddit Format (Markdown unterstÃ¼tzt)\nlet redditText = `# ${item.eventTitle}\\n\\n**ğŸ“… Date:** ${item.formattedDate}\\n**ğŸ• Time:** ${item.eventTime}\\n**ğŸ“ Location:** ${item.venue}, ${item.city}\\n\\n${item.description || ''}\\n\\n---\\n\\n**Event Details:**\\n- **Venue:** ${item.venue}\\n- **City:** ${item.city}\\n- **Date:** ${item.formattedDate}\\n- **Time:** ${item.eventTime}`;\n\nif (item.ticketUrl) {\n  redditText += `\\n\\n**ğŸ« [Get Tickets](${item.ticketUrl})**`;\n}\n\nif (item.imageUrl) {\n  redditText += `\\n\\n![Event Image](${item.imageUrl})`;\n}\n\nredditText += `\\n\\n---\\n\\n*Posted by automated system*`;\n\n// Email format (HTML) / E-Mail Format (HTML)\nconst emailHtml = `\\n  <h2>${item.eventTitle}</h2>\\n  <p><strong>ğŸ“… Date:</strong> ${item.formattedDate}</p>\\n  <p><strong>ğŸ• Time:</strong> ${item.eventTime}</p>\\n  <p><strong>ğŸ“ Location:</strong> ${item.venue}, ${item.city}</p>\\n  ${item.description ? `<p>${item.description}</p>` : ''}\\n  ${item.ticketUrl ? `<p><a href=\"${item.ticketUrl}\" style=\"background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;\">ğŸ« Get Tickets</a></p>` : ''}\\n`;\n\nconst emailText = `${item.eventTitle}\\n\\nDate: ${item.formattedDate}\\nTime: ${item.eventTime}\\nLocation: ${item.venue}, ${item.city}\\n\\n${item.description || ''}\\n\\n${item.ticketUrl ? `Tickets: ${item.ticketUrl}` : ''}`;\n\nreturn [{\n  json: {\n    ...item,\n    twitterText: twitterText,\n    instagramText: instagramText,\n    facebookText: facebookText,\n    linkedinText: linkedinText,\n    redditText: redditText,\n    emailHtml: emailHtml,\n    emailText: emailText\n  }\n}];\n"
      },
      "id": "5823eac4-7520-1b96-437e-a4c949968b15",
      "name": "âœï¸ Format Content for Platforms",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -920
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Generate relevant hashtags for different platforms\n// DE: Relevante Hashtags fÃ¼r verschiedene Plattformen generieren\n\nconst item = $input.item.json;\n\n// Base hashtags for different categories\nconst hashtagDatabase = {\n  music: ['#Music', '#LiveMusic', '#Concert', '#DJ', '#Techno', '#House', '#Electronic'],\n  location: (city) => [`#${city.replace(/\\s+/g, '')}`, `#${city}Events`, `#${city}Nightlife`],\n  event: ['#Event', '#Nightlife', '#Club', '#Party', '#Festival', '#LiveEvent'],\n  platform: {\n    instagram: ['#Instamusic', '#ClubLife', '#NightOut'],\n    twitter: ['#NowPlaying', '#MusicEvent'],\n    facebook: ['#LocalEvent', '#Community'],\n    linkedin: ['#Networking', '#ProfessionalEvent'],\n    reddit: ['#MusicCommunity', '#EventShare']\n  }\n};\n\nfunction generateHashtags() {\n  const hashtags = new Set();\n\n  // Add music-related hashtags\n  hashtagDatabase.music.forEach(tag => hashtags.add(tag));\n\n  // Add location-based hashtags\n  if (item.city) {\n    const locationTags = hashtagDatabase.location(item.city);\n    locationTags.forEach(tag => hashtags.add(tag));\n  }\n\n  // Add event-related hashtags\n  hashtagDatabase.event.forEach(tag => hashtags.add(tag));\n\n  // Add platform-specific hashtags\n  for (const [platform, enabled] of Object.entries(item.publishTo || {})) {\n    if (enabled && hashtagDatabase.platform[platform]) {\n      hashtagDatabase.platform[platform].forEach(tag => hashtags.add(tag));\n    }\n  }\n\n  // Extract hashtags from description\n  if (item.description) {\n    const descriptionHashtags = item.description.match(/#\\w+/g);\n    if (descriptionHashtags) {\n      descriptionHashtags.forEach(tag => hashtags.add(tag));\n    }\n  }\n\n  // Convert to array and sort\n  const result = Array.from(hashtags).sort();\n\n  // Limit to reasonable amount per platform\n  const limits = {\n    twitter: 5,      // Twitter prefers fewer hashtags\n    instagram: 10,   // Instagram can handle more\n    facebook: 8,\n    linkedin: 3,     // LinkedIn prefers professional look\n    reddit: 5,\n    email: 0         // Email usually doesn't need hashtags\n  };\n\n  return result.slice(0, limits[item.currentPlatform] || 5);\n}\n\n// Generate hashtags for each platform\nconst enhancedItem = { ...item };\n\nfor (const [platform, enabled] of Object.entries(item.publishTo || {})) {\n  if (enabled) {\n    // Temporarily set current platform for hashtag generation\n    enhancedItem.currentPlatform = platform;\n    const platformHashtags = generateHashtags();\n\n    // Add hashtags to platform-specific text\n    const textKey = `${platform}Text`;\n    if (enhancedItem[textKey]) {\n      // Only add hashtags if not already present\n      const existingHashtags = enhancedItem[textKey].match(/#\\w+/g) || [];\n      const newHashtags = platformHashtags.filter(tag => !existingHashtags.includes(tag));\n\n      if (newHashtags.length > 0) {\n        enhancedItem[textKey] += '\\n\\n' + newHashtags.join(' ');\n      }\n    }\n\n    enhancedItem[`${platform}Hashtags`] = platformHashtags;\n  }\n}\n\nreturn [{\n  json: {\n    ...enhancedItem,\n    hashtagsGenerated: true,\n    generatedAt: new Date().toISOString()\n  }\n}];\n"
      },
      "id": "9dc9eeb8-d1da-40bc-4417-b55f9b79dc2c",
      "name": "ğŸ·ï¸ Generate Hashtags",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        260,
        -920
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Collect results from all posting operations\n// DE: Sammelt Ergebnisse aller Posting-Operationen\nconst results = [];\nconst allItems = $input.all();\n\n// Get original event data from first item / Hole ursprÃ¼ngliche Event-Daten vom ersten Item\nconst inputData = allItems[0]?.json || {};\n\n// Platform detection from data / Plattform-Erkennung aus Daten\nconst detectPlatform = (item) => {\n  // Check for platform-specific fields / PrÃ¼fe plattform-spezifische Felder\n  if (item.id_str || item.id) return 'Twitter/X';\n  if (item.instagram_id || item.media_id) return 'Instagram';\n  if (item.post_id || item.facebook_id) return 'Facebook';\n  if (item.linkedin_id || item.urn) return 'LinkedIn';\n  if (item.messageId || item.emailId) return 'Email';\n  if (item.name && item.name.startsWith('t3_')) return 'Reddit';\n  // Fallback: check for error or success indicators / Fallback: PrÃ¼fe Fehler- oder Erfolgs-Indikatoren\n  if (item.error) return 'Unknown Platform';\n  return 'Unknown Platform';\n};\n\n// Collect all outputs / Alle Ausgaben sammeln\nallItems.forEach((item) => {\n  const platform = detectPlatform(item.json);\n  const hasError = item.json.error || item.json.errorMessage || false;\n\n  results.push({\n    platform: platform,\n    success: !hasError,\n    data: item.json,\n    timestamp: new Date().toISOString()\n  });\n});\n\n// If no results collected, create summary from input / Falls keine Ergebnisse gesammelt, erstelle Zusammenfassung aus Eingabe\nif (results.length === 0 && inputData.eventTitle) {\n  results.push({\n    platform: 'No platforms enabled',\n    success: true,\n    data: { message: 'No platforms were enabled for posting' },\n    timestamp: new Date().toISOString()\n  });\n}\n\nreturn [{\n  json: {\n    eventTitle: inputData.eventTitle || 'Unknown Event',\n    eventDate: inputData.eventDate || '',\n    timestamp: new Date().toISOString(),\n    results: results,\n    summary: {\n      total: results.length,\n      successful: results.filter(r => r.success).length,\n      failed: results.filter(r => !r.success).length\n    }\n  }\n}];\n"
      },
      "id": "67620867-d83e-dbb1-4e84-955f64112179",
      "name": "ğŸ“Š Collect Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        -940
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Enhanced logging and monitoring for all posting operations\n// DE: Erweiterte Protokollierung und Ãœberwachung aller Posting-Operationen\n\nconst item = $input.item.json;\n\n// Create detailed execution log\nconst executionLog = {\n  eventId: `${item.eventTitle}-${Date.now()}`,\n  timestamp: new Date().toISOString(),\n  event: {\n    title: item.eventTitle,\n    date: item.eventDate,\n    venue: item.venue,\n    city: item.city\n  },\n  platforms: {},\n  summary: {\n    totalPlatforms: 0,\n    successful: 0,\n    failed: 0,\n    skipped: 0\n  }\n};\n\n// Analyze platform results\nif (item.results && Array.isArray(item.results)) {\n  item.results.forEach(result => {\n    executionLog.summary.totalPlatforms++;\n\n    executionLog.platforms[result.platform] = {\n      success: result.success,\n      timestamp: result.timestamp,\n      data: result.data\n    };\n\n    if (result.success) {\n      executionLog.summary.successful++;\n    } else {\n      executionLog.summary.failed++;\n    }\n  });\n}\n\n// Calculate skipped platforms\nconst enabledPlatforms = Object.keys(item.publishTo || {}).filter(p => item.publishTo[p]);\nexecutionLog.summary.skipped = enabledPlatforms.length - executionLog.summary.totalPlatforms;\n\n// Performance metrics\nexecutionLog.performance = {\n  totalDuration: Date.now() - new Date(item.timestamp).getTime(),\n  platformsPerSecond: executionLog.summary.totalPlatforms / ((Date.now() - new Date(item.timestamp).getTime()) / 1000)\n};\n\n// Generate human-readable summary\nlet summaryText = `ğŸ« Event: ${item.eventTitle}\\n`;\nsummaryText += `ğŸ“… Date: ${item.formattedDate}\\n`;\nsummaryText += `ğŸ“ Location: ${item.venue}, ${item.city}\\n\\n`;\n\nsummaryText += `ğŸ“Š Posting Results:\\n`;\nsummaryText += `âœ… Successful: ${executionLog.summary.successful}\\n`;\nsummaryText += `âŒ Failed: ${executionLog.summary.failed}\\n`;\nsummaryText += `â­ï¸  Skipped: ${executionLog.summary.skipped}\\n\\n`;\n\nif (executionLog.summary.failed > 0) {\n  summaryText += `âš ï¸  Failed Platforms:\\n`;\n  Object.entries(executionLog.platforms).forEach(([platform, data]) => {\n    if (!data.success) {\n      summaryText += `â€¢ ${platform}: ${data.data?.error || 'Unknown error'}\\n`;\n    }\n  });\n}\n\n// Log to console for n8n logs\nconsole.log('='.repeat(50));\nconsole.log('ğŸ« MULTI-PLATFORM POSTING LOG');\nconsole.log('='.repeat(50));\nconsole.log(summaryText);\nconsole.log(`â±ï¸  Total Duration: ${executionLog.performance.totalDuration}ms`);\nconsole.log('='.repeat(50));\n\n// Return enhanced data\nreturn [{\n  json: {\n    ...item,\n    executionLog: executionLog,\n    summaryText: summaryText,\n    logGenerated: true\n  }\n}];\n"
      },
      "id": "85af0bda-bf6f-bf40-4246-ac4b0132fc2a",
      "name": "ğŸ“‹ Enhanced Logging",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1240,
        -940
      ]
    },
    {
      "parameters": {
        "jsCode": "// EN: Send notifications to Discord/Telegram about posting results\n// DE: Sende Benachrichtigungen an Discord/Telegram Ã¼ber Posting-Ergebnisse\n\nconst item = $input.item.json;\nconst axios = require('axios');\n\nasync function sendDiscordNotification(webhookUrl, message) {\n  try {\n    await axios.post(webhookUrl, {\n      content: message,\n      embeds: [{\n        title: \"ğŸ« Multi-Platform Event Posting\",\n        description: item.summaryText,\n        color: item.executionLog?.summary?.failed > 0 ? 0xff0000 : 0x00ff00,\n        fields: [\n          {\n            name: \"ğŸ“Š Results\",\n            value: `âœ… ${item.executionLog?.summary?.successful || 0} | âŒ ${item.executionLog?.summary?.failed || 0} | â­ï¸ ${item.executionLog?.summary?.skipped || 0}`,\n            inline: true\n          },\n          {\n            name: \"â±ï¸ Duration\",\n            value: `${item.executionLog?.performance?.totalDuration || 0}ms`,\n            inline: true\n          },\n          {\n            name: \"ğŸ“… Event\",\n            value: `${item.eventTitle} - ${item.formattedDate}`,\n            inline: false\n          }\n        ],\n        timestamp: new Date().toISOString()\n      }]\n    });\n    return { platform: 'discord', success: true };\n  } catch (error) {\n    return { platform: 'discord', success: false, error: error.message };\n  }\n}\n\nasync function sendTelegramNotification(botToken, chatId, message) {\n  try {\n    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;\n    await axios.post(url, {\n      chat_id: chatId,\n      text: message,\n      parse_mode: 'HTML',\n      disable_web_page_preview: true\n    });\n    return { platform: 'telegram', success: true };\n  } catch (error) {\n    return { platform: 'telegram', success: false, error: error.message };\n  }\n}\n\nasync function main() {\n  const notifications = [];\n\n  // Discord Notification\n  const discordWebhook = $env.DISCORD_WEBHOOK_URL;\n  if (discordWebhook) {\n    console.log('ğŸ“¢ Sending Discord notification...');\n    const discordResult = await sendDiscordNotification(discordWebhook, item.summaryText);\n    notifications.push(discordResult);\n\n    if (discordResult.success) {\n      console.log('âœ… Discord notification sent');\n    } else {\n      console.error('âŒ Discord notification failed:', discordResult.error);\n    }\n  }\n\n  // Telegram Notification\n  const telegramBotToken = $env.TELEGRAM_BOT_TOKEN;\n  const telegramChatId = $env.TELEGRAM_CHAT_ID;\n\n  if (telegramBotToken && telegramChatId) {\n    console.log('ğŸ“¢ Sending Telegram notification...');\n\n    // Format message for Telegram (HTML)\n    const telegramMessage = `\nğŸ« <b>Multi-Platform Event Posting</b>\n\nğŸ“… <b>${item.eventTitle}</b>\nğŸ“ ${item.venue}, ${item.city}\nğŸ• ${item.formattedDate}\n\nğŸ“Š <b>Results:</b>\nâœ… Successful: ${item.executionLog?.summary?.successful || 0}\nâŒ Failed: ${item.executionLog?.summary?.failed || 0}\nâ­ï¸ Skipped: ${item.executionLog?.summary?.skipped || 0}\n\nâ±ï¸ Duration: ${item.executionLog?.performance?.totalDuration || 0}ms\n    `.trim();\n\n    const telegramResult = await sendTelegramNotification(telegramBotToken, telegramChatId, telegramMessage);\n    notifications.push(telegramResult);\n\n    if (telegramResult.success) {\n      console.log('âœ… Telegram notification sent');\n    } else {\n      console.error('âŒ Telegram notification failed:', telegramResult.error);\n    }\n  }\n\n  // If no notification methods configured, log to console\n  if (notifications.length === 0) {\n    console.log('â„¹ï¸  No notification methods configured');\n    console.log('ğŸ“Š Posting Summary:');\n    console.log(item.summaryText);\n  }\n\n  return [{\n    json: {\n      ...item,\n      notifications: notifications,\n      notificationsSent: notifications.length > 0,\n      notificationTimestamp: new Date().toISOString()\n    }\n  }];\n}\n\nreturn main();\n"
      },
      "id": "5b113556-0105-8e2a-43e8-b75fd3af7a67",
      "name": "ğŸ“¢ Send Notifications",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -940
      ]
    },
    {
      "parameters": {
        "assignments": [
          {
            "id": "merge-001",
            "name": "finalResult",
            "value": "={{ $json }}",
            "type": "object"
          }
        ]
      },
      "id": "d91bd30c-2921-332f-4cbd-8a6e447fa8a2",
      "name": "ğŸ”€ Merge Results",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1560,
        -940
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.twitter }}"
            }
          ]
        },
        "additionalFields": {}
      },
      "id": "9b235081-7c85-c87b-4929-becf7057566d",
      "name": "ğŸ¦ Post to Twitter/X?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -1340
      ]
    },
    {
      "parameters": {
        "additionalFields": {}
      },
      "id": "2c3fe310-333f-277b-4f32-ab8676d78d8b",
      "name": "ğŸ¦ Post to Twitter/X",
      "type": "n8n-nodes-base.twitter",
      "typeVersion": 2,
      "position": [
        680,
        -1340
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.instagram }}"
            }
          ]
        },
        "additionalFields": {}
      },
      "id": "780e148d-85b9-639f-4d15-836c6d558325",
      "name": "ğŸ“· Post to Instagram?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -1160
      ]
    },
    {
      "parameters": {
        "additionalFields": {}
      },
      "id": "0088e969-08ca-7f61-457e-9b96c9b9ae29",
      "name": "ğŸ“· Post to Instagram",
      "type": "n8n-nodes-base.instagram",
      "typeVersion": 1,
      "position": [
        680,
        -1160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.facebook }}"
            }
          ]
        },
        "additionalFields": {}
      },
      "id": "2b3674c3-9ad8-5f3b-4b8a-8844a4829632",
      "name": "ğŸ‘¤ Post to Facebook?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -960
      ]
    },
    {
      "parameters": {
        "additionalFields": {}
      },
      "id": "bc4d5d06-12ab-45fd-4c7d-81ec0d2322db",
      "name": "ğŸ‘¤ Post to Facebook Page",
      "type": "n8n-nodes-base.facebook",
      "typeVersion": 2.1,
      "position": [
        680,
        -960
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.linkedin }}"
            }
          ]
        },
        "additionalFields": {}
      },
      "id": "fc65904b-3706-7780-4226-b3416b384a85",
      "name": "ğŸ’¼ Post to LinkedIn?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -780
      ]
    },
    {
      "parameters": {
        "additionalFields": {}
      },
      "id": "f9b38ec4-95d1-2ef2-4fa3-90e70845597a",
      "name": "ğŸ’¼ Post to LinkedIn",
      "type": "n8n-nodes-base.linkedIn",
      "typeVersion": 1,
      "position": [
        680,
        -780
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.email && $json.emailRecipients && $json.emailRecipients.length > 0 }}"
            }
          ]
        }
      },
      "id": "669903d2-b36d-5ec7-4d7d-a5fe796e212a",
      "name": "ğŸ“§ Send Email?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -600
      ]
    },
    {
      "parameters": {
        "fromEmail": "={{ $env.EMAIL_FROM || 'noreply@example.com' }}",
        "toEmail": "={{ $json.emailRecipients.join(',') }}",
        "subject": "={{ $json.eventTitle }} - {{ $json.formattedDate }}",
        "html": "={{ $json.emailHtml }}",
        "options": {
          "attachments": "={{ $json.imageUrl ? [{ url: $json.imageUrl, name: 'event-image.jpg' }] : [] }}"
        }
      },
      "id": "759aad6f-89e1-c521-4728-9c3c10aa5117",
      "name": "ğŸ“§ Send Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        680,
        -600
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.publishTo.reddit && $json.redditSubreddit }}"
            }
          ]
        }
      },
      "id": "a4723b69-5eea-653b-4de3-834ea019da1d",
      "name": "ğŸ”´ Post to Reddit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        420,
        -400
      ]
    },
    {
      "parameters": {
        "resource": "post",
        "subreddit": "DJs",
        "title": "={{ $json.eventTitle }}",
        "text": "={{ $json.redditText }}",
        "additionalFields": {}
      },
      "id": "ebab7789-9a78-84d0-4746-823b1570e99c",
      "name": "ğŸ”´ Post to Reddit",
      "type": "n8n-nodes-base.reddit",
      "typeVersion": 1,
      "position": [
        680,
        -400
      ]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "0b96c802-0f57-4ef6-4700-89c6caae9042",
      "name": "âœ… Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1760,
        -940
      ]
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "sendTo": "user",
        "userId": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "options": {}
      },
      "id": "eb638535-6f25-008d-414d-b30fe88ce5fd",
      "name": "Discord",
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        1760,
        -780
      ]
    },
    {
      "parameters": {
        "additionalFields": {}
      },
      "id": "66f72527-2972-c9f2-4838-a0bb98dd78d1",
      "name": "Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1760,
        -1100
      ]
    },
    {
      "parameters": {
        "content": "# ğŸš€ Multi-Platform Social Media & Email Publisher\n\n**EN:** This workflow publishes DJ events (or any events) to multiple social media platforms and sends emails simultaneously.\n\n**DE:** Dieser Workflow verÃ¶ffentlicht DJ-Events (oder beliebige Events) auf mehreren Social-Media-Plattformen und sendet gleichzeitig E-Mails.\n\n## ğŸ“‹ Supported Platforms / UnterstÃ¼tzte Plattformen\n\n- ğŸ¦ **Twitter/X** - Text + Images\n- ğŸ“· **Instagram** - Images + Captions\n- ğŸ‘¤ **Facebook** - Posts + Images\n- ğŸ’¼ **LinkedIn** - Professional Posts\n- ğŸ”´ **Reddit** - Subreddit Posts with Flairs\n- ğŸ“§ **Email** - HTML + Plain Text\n\n## âš™ï¸ How to Use / Verwendung\n\n1. **Configure Credentials** - See panels below for each platform\n2. **Send POST request** to webhook with event data\n3. **Enable/Disable platforms** via `publishTo` object\n\n## ğŸ“ Input Format\n\nSee \"ğŸ“¥ Input Format\" panel below for complete example.\n\n---\n\n*(Doppelklick zum Bearbeiten | [n8n Sticky Notes Guide](https://docs.n8n.io/workflows/sticky-notes/))*\n",
        "height": 600,
        "width": 800,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        380,
        100
      ],
      "id": "overview",
      "name": "ğŸ“‹ Overview"
    },
    {
      "parameters": {
        "content": "# ğŸ“¥ Input Format / Eingabeformat\n\n## Required Fields / Pflichtfelder\n\n```json\n{\n  \"eventTitle\": \"DJ Night @ Club XYZ\",\n  \"eventDate\": \"2025-05-15\",\n  \"venue\": \"Club XYZ\",\n  \"city\": \"Berlin\"\n}\n```\n\n## Complete Example / VollstÃ¤ndiges Beispiel\n\n```json\n{\n  \"eventTitle\": \"Techno Night @ Berghain\",\n  \"eventDate\": \"2025-05-15\",\n  \"eventTime\": \"23:00\",\n  \"venue\": \"Berghain\",\n  \"city\": \"Berlin\",\n  \"description\": \"Join us for an unforgettable night!\",\n  \"imageUrl\": \"https://example.com/image.jpg\",\n  \"ticketUrl\": \"https://tickets.example.com\",\n  \"publishTo\": {\n    \"twitter\": true,\n    \"instagram\": true,\n    \"facebook\": true,\n    \"linkedin\": false,\n    \"reddit\": true,\n    \"email\": true\n  },\n  \"emailRecipients\": [\"fan@example.com\"],\n  \"redditSubreddit\": \"DJs\",\n  \"redditFlair\": \"Event\",\n  \"redditNsfw\": false,\n  \"redditSpoiler\": false\n}\n```\n\n---\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 700,
        "width": 600,
        "color": 1
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -420,
        -380
      ],
      "id": "input-format",
      "name": "ğŸ“¥ Input Format"
    },
    {
      "parameters": {
        "content": "# ğŸ” Credentials Setup / Credentials einrichten\n\n## âš ï¸ WICHTIG: Separate Credentials!\n\n**Jede Plattform benÃ¶tigt EIGENE Credentials!**\n\n## Checklist / Checkliste\n\n- [ ] **Twitter/X**: `TWITTER_CREDENTIALS_ID`\n- [ ] **Instagram**: `INSTAGRAM_CREDENTIALS_ID`\n- [ ] **Facebook**: `FACEBOOK_CREDENTIALS_ID`\n- [ ] **LinkedIn**: `LINKEDIN_CREDENTIALS_ID`\n- [ ] **Reddit**: `REDDIT_CREDENTIALS_ID`\n- [ ] **Email**: `SMTP_CREDENTIALS_ID`\n\n## ğŸ“š Detailed Instructions\n\nSee individual credential panels below for each platform.\n\nSiehe einzelne Credential-Panels unten fÃ¼r jede Plattform.\n\n---\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 500,
        "width": 600,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -420,
        360
      ],
      "id": "credentials-overview",
      "name": "ğŸ” Credentials Overview"
    },
    {
      "parameters": {
        "content": "# ğŸ¦ Twitter/X Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\n1. Go to: **https://developer.twitter.com/**\n2. Create App â†’ **API Keys & Tokens**\n3. You need:\n   - **API Key** (Consumer Key)\n   - **API Secret** (Consumer Secret)\n   - **Access Token**\n   - **Access Token Secret**\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **Twitter OAuth1 API**\n3. Enter all 4 values\n4. Assign to node: **ğŸ¦ Post to Twitter/X**\n\n---\n\n**Credential ID:** `TWITTER_CREDENTIALS_ID`\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 450,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1500,
        -420
      ],
      "id": "twitter-credentials",
      "name": "ğŸ¦ Twitter Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ“· Instagram Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\nâš ï¸ **Requires Facebook Business Account**\n\n1. Go to: **https://developers.facebook.com/**\n2. Create **Meta App** (Type: **Business**)\n3. Add **Instagram Graph API** product\n4. You need:\n   - **App ID**\n   - **App Secret**\n   - **Access Token** (with permissions)\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **Instagram OAuth2 API**\n3. Enter credentials\n4. Assign to node: **ğŸ“· Post to Instagram**\n\n---\n\n**Credential ID:** `INSTAGRAM_CREDENTIALS_ID`\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 710,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1480,
        360
      ],
      "id": "instagram-credentials",
      "name": "ğŸ“· Instagram Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ‘¤ Facebook Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\n1. Go to: **https://developers.facebook.com/**\n2. Create **Meta App** (Type: **Business**)\n3. Add **Facebook Login** product\n4. You need:\n   - **App ID**\n   - **App Secret**\n   - **Page Access Token** (with `pages_manage_posts`)\n   - **Page ID** (set as env var `FACEBOOK_PAGE_ID`)\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **Facebook OAuth2 API**\n3. Enter credentials\n4. Set env var: `FACEBOOK_PAGE_ID=your_page_id`\n5. Assign to node: **ğŸ‘¤ Post to Facebook Page**\n\n---\n\n**Credential ID:** `FACEBOOK_CREDENTIALS_ID`\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 680,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2020,
        360
      ],
      "id": "facebook-credentials",
      "name": "ğŸ‘¤ Facebook Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ’¼ LinkedIn Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\n1. Go to: **https://www.linkedin.com/developers/apps**\n2. Create new app\n3. You need:\n   - **Client ID**\n   - **Client Secret**\n4. Configure **OAuth Redirect URL**:\n   `https://your-n8n-instance.com/rest/oauth2-credential/callback`\n5. Request permissions: `w_member_social`, `w_organization_social`\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **LinkedIn OAuth2 API**\n3. Enter Client ID and Secret\n4. Complete OAuth flow\n5. Assign to node: **ğŸ’¼ Post to LinkedIn**\n\n---\n\n**Credential ID:** `LINKEDIN_CREDENTIALS_ID`\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 500,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2060,
        -420
      ],
      "id": "linkedin-credentials",
      "name": "ğŸ’¼ LinkedIn Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ”´ Reddit Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\n1. Go to: **https://www.reddit.com/prefs/apps**\n2. Click **\"create app\"**\n3. Fill in:\n   - **Name**: Your app name\n   - **App type**: **\"script\"**\n   - **Redirect URI**: `http://localhost:8080`\n4. Note:\n   - **Client ID** (under app name)\n   - **Client Secret** (only shown once!)\n5. Get OAuth Token:\n   - Use: https://not-an-aardvark.github.io/reddit-oauth-helper/\n   - Token format: `Bearer YOUR_ACCESS_TOKEN`\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **HTTP Header Auth**\n3. Configure:\n   - **Name**: `Authorization`\n   - **Value**: `Bearer YOUR_ACCESS_TOKEN`\n4. Assign to node: **ğŸ”´ Post to Reddit**\n\n---\n\n**Credential ID:** `REDDIT_CREDENTIALS_ID`\n\n**Reddit Fields:**\n- `redditSubreddit`: Required (e.g., \"DJs\")\n- `redditFlair`: Optional\n- `redditNsfw`: true/false\n- `redditSpoiler`: true/false\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 960,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2600,
        360
      ],
      "id": "reddit-credentials",
      "name": "ğŸ”´ Reddit Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ“§ Email (SMTP) Credentials\n\n## CREDENTIALS REQUIRED / CREDENTIALS ERFORDERLICH\n\n### Gmail:\n1. Enable **2-Factor Authentication**\n2. Go to: **https://myaccount.google.com/apppasswords**\n3. Generate **App Password** for \"Mail\"\n4. Use this password (not your regular password)\n\n### SMTP Settings:\n- **Host**: `smtp.gmail.com`\n- **Port**: `587` (TLS) or `465` (SSL)\n- **User**: your-email@gmail.com\n- **Password**: App Password (for Gmail)\n\n## In n8n:\n\n1. **Settings** â†’ **Credentials** â†’ **Add Credential**\n2. Select **SMTP**\n3. Enter SMTP settings\n4. Optional: Set `EMAIL_FROM` env var\n5. Assign to node: **ğŸ“§ Send Email**\n\n---\n\n**Credential ID:** `SMTP_CREDENTIALS_ID`\n\n**Other Providers:**\n- Outlook: `smtp.office365.com`\n- Custom: Use your provider's SMTP settings\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 550,
        "width": 500,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2680,
        -440
      ],
      "id": "email-credentials",
      "name": "ğŸ“§ Email Credentials"
    },
    {
      "parameters": {
        "content": "# ğŸ“¢ Discord & Telegram Notifications\n\n## Discord Webhook Setup\n\n1. **Go to your Discord server**\n2. **Right-click on a channel** â†’ **Edit Channel** â†’ **Integrations** â†’ **Webhooks**\n3. **Create new Webhook** with a name (e.g., \"n8n-workflow\")\n4. **Copy the Webhook URL**\n\n## In n8n Environment Variables:\n```bash\nDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/YOUR_WEBHOOK_ID/YOUR_WEBHOOK_TOKEN\n```\n\n## Telegram Bot Setup\n\n1. **Message @BotFather** on Telegram\n2. **Send:** `/newbot`\n3. **Follow instructions** to create your bot\n4. **Get your Bot Token** from BotFather\n\n## In n8n Environment Variables:\n```bash\nTELEGRAM_BOT_TOKEN=1234567890:ABCdefGHIjklMNOpqrsTUVwxyz\nTELEGRAM_CHAT_ID=123456789\n```\n\n### How to get Chat ID:\n1. **Message your bot** with any text\n2. **Visit:** `https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates`\n3. **Find your chat ID** in the response\n\n## Features:\n- âœ… **Rich Discord embeds** with colors and formatting\n- âœ… **HTML Telegram messages** with markup\n- âœ… **Success/Failure indicators** with colors\n- âœ… **Performance metrics** included\n- âœ… **Automatic fallbacks** to console logging\n\n## Example Notification:\n\n**Discord:** Rich embed with event details, success rates, and timing\n**Telegram:** Formatted message with HTML markup and statistics\n\n---\n\n*(Doppelklick zum Bearbeiten)*\n",
        "height": 600,
        "width": 700,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3240,
        360
      ],
      "id": "discord-telegram-setup",
      "name": "ğŸ“¢ Discord & Telegram Setup"
    }
  ],
  "connections": {
    "Interface Webhook": {
      "main": [
        [
          {
            "node": "ğŸ” Validate & Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "On form submission": {
      "main": [
        [
          {
            "node": "ğŸ” Validate & Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ Manual File Path Input": {
      "main": [
        [
          {
            "node": "ğŸ“„ Read File from Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“„ Read File from Path": {
      "main": [
        [
          {
            "node": "ğŸ” Parse Manual Input (Markdown/Image)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Parse Manual Input (Markdown/Image)": {
      "main": [
        [
          {
            "node": "ğŸ” Validate & Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ File Upload (PDF/PNG/JPG)": {
      "main": [
        [
          {
            "node": "ğŸ” Validate & Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Send Email?": {
      "main": [
        [
          {
            "node": "ğŸ“§ Send Email",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "ğŸ“§ Send Email": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¥ Webhook Trigger (API)": {
      "main": [
        [
          {
            "node": "ğŸ” Validate & Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Validate & Prepare Data": {
      "main": [
        [
          {
            "node": "âœ… Validate Platforms",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "âœ… Validate Platforms": {
      "main": [
        [
          {
            "node": "ğŸ”— Validate URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”— Validate URLs": {
      "main": [
        [
          {
            "node": "âœï¸ Format Content for Platforms",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "âœï¸ Format Content for Platforms": {
      "main": [
        [
          {
            "node": "ğŸ·ï¸ Generate Hashtags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ·ï¸ Generate Hashtags": {
      "main": [
        [
          {
            "node": "ğŸ¦ Post to Twitter/X?",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ“· Post to Instagram?",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ‘¤ Post to Facebook?",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ’¼ Post to LinkedIn?",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ“§ Send Email?",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ”´ Post to Reddit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ¦ Post to Twitter/X?": {
      "main": [
        [
          {
            "node": "ğŸ¦ Post to Twitter/X",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "ğŸ“· Post to Instagram?": {
      "main": [
        [
          {
            "node": "ğŸ“· Post to Instagram",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "ğŸ‘¤ Post to Facebook?": {
      "main": [
        [
          {
            "node": "ğŸ‘¤ Post to Facebook Page",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "ğŸ’¼ Post to LinkedIn?": {
      "main": [
        [
          {
            "node": "ğŸ’¼ Post to LinkedIn",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "email-send": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”´ Post to Reddit?": {
      "main": [
        [
          {
            "node": "ğŸ”´ Post to Reddit",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "ğŸ¦ Post to Twitter/X": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“· Post to Instagram": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ‘¤ Post to Facebook Page": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ’¼ Post to LinkedIn": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”´ Post to Reddit": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "reddit-post": {
      "main": [
        [
          {
            "node": "ğŸ“Š Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“Š Collect Results": {
      "main": [
        [
          {
            "node": "ğŸ“‹ Enhanced Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“‹ Enhanced Logging": {
      "main": [
        [
          {
            "node": "ğŸ“¢ Send Notifications",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¢ Send Notifications": {
      "main": [
        [
          {
            "node": "Discord",
            "type": "main",
            "index": 0
          },
          {
            "node": "Telegram",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ”€ Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Merge Results": {
      "main": [
        [
          {
            "node": "âœ… Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "7302af2d76ff11fa25dfe4c4b676102587b05b140a7ac12e86e85bb8179e9e38"
  }
}