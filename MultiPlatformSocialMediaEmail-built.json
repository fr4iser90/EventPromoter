{
  "name": "Multi-Platform API Executor - PRE-FORMATTED CONTENT",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Structure all platform responses into unified format\nconst result = {\n  success: true,\n  data: {}\n};\n\n// Platform mapping from node names/response patterns\nconst platformPatterns = {\n  'twitter': ['twitter', 'tweet', 'id_str'],\n  'instagram': ['instagram', 'media_id'],\n  'facebook': ['facebook', 'pageId'],\n  'linkedin': ['linkedin', 'urn'],\n  'reddit': ['reddit', 'subreddit', 'name'],\n  'email': ['email', 'recipients', 'messageId']\n};\n\n// Process all incoming items\nfor (const item of $input.all()) {\n  const json = item.json || {};\n  const responseData = json.json || json;\n  \n  // Try to identify platform\n  let platform = null;\n  \n  // Method 1: Check if platform is explicitly set\n  if (json.platform) {\n    platform = json.platform;\n  }\n  // Method 2: Check response data patterns\n  else {\n    for (const [platformName, patterns] of Object.entries(platformPatterns)) {\n      if (patterns.some(pattern => \n        json[pattern] !== undefined || \n        responseData[pattern] !== undefined ||\n        JSON.stringify(json).toLowerCase().includes(pattern) ||\n        JSON.stringify(responseData).toLowerCase().includes(pattern)\n      )) {\n        platform = platformName;\n        break;\n      }\n    }\n  }\n  \n  if (platform) {\n    // Extract response data based on platform\n    const extracted = {\n      success: responseData.success !== false && !responseData.error && responseData.errorCode === undefined,\n      error: responseData.error || responseData.errorMessage || (responseData.success === false ? responseData.message : undefined)\n    };\n    \n    // Platform-specific extraction\n    if (platform === 'twitter') {\n      extracted.postId = responseData.id_str || responseData.id;\n      extracted.url = responseData.url || (extracted.postId ? `https://twitter.com/i/web/status/${extracted.postId}` : undefined);\n    } else if (platform === 'reddit') {\n      extracted.postId = responseData.id || responseData.name?.replace('t3_', '');\n      extracted.url = responseData.url || responseData.permalink || (extracted.postId ? `https://reddit.com${responseData.permalink || ''}` : undefined);\n    } else if (platform === 'email') {\n      extracted.postId = responseData.messageId || responseData.id;\n      // Emails don't have URLs\n    } else if (platform === 'instagram') {\n      extracted.postId = responseData.id || responseData.media_id;\n      extracted.url = responseData.url || (extracted.postId ? `https://instagram.com/p/${extracted.postId}/` : undefined);\n    } else if (platform === 'facebook') {\n      extracted.postId = responseData.id;\n      extracted.url = responseData.url || (extracted.postId ? `https://facebook.com/${extracted.postId}` : undefined);\n    } else if (platform === 'linkedin') {\n      extracted.postId = responseData.id || responseData.urn?.split(':').pop();\n      extracted.url = responseData.url || (extracted.postId ? `https://linkedin.com/feed/update/${extracted.postId}` : undefined);\n    }\n    \n    // Remove undefined fields\n    Object.keys(extracted).forEach(key => {\n      if (extracted[key] === undefined) delete extracted[key];\n    });\n    \n    result.data[platform] = extracted;\n  }\n}\n\n// Check if any platform failed\nconst allSuccess = Object.values(result.data).every(p => p.success !== false);\nresult.success = allSuccess && Object.keys(result.data).length > 0;\n\nreturn result;\n"
      },
      "id": "26fb8d5c-63b7-aa84-4623-a557accaa6df",
      "name": "ğŸ”§ Structure Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17460,
        5080
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "0b96c802-0f57-4ef6-4700-89c6caae9042",
      "name": "âœ… Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        17760,
        5080
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dj-event",
        "responseMode": "responseNode"
      },
      "id": "db1cb1a8-09b5-b190-4903-8a112cff091b",
      "name": "ğŸ“¥ Webhook Trigger (API) - PRE-FORMATTED CONTENT",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        13360,
        5080
      ],
      "webhookId": "dj-event-webhook"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.body?.email && typeof $json.body.email === 'object' }}",
              "value2": true
            }
          ]
        },
        "options": {
          "alwaysOutputData": true
        }
      },
      "id": "669903d2-b36d-5ec7-4d7d-a5fe796e212a",
      "name": "ğŸ“§ Has Email Content?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        14160,
        5680
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare email data - extract email from body.email\n// Webhook contract: { body: { email: {...} } }\n// Workflow contract: { email: {...} }\n\nconst input = $input.item.json;\n\n// If-Node verified: $json.body?.email && typeof $json.body.email === 'object'\n// Email is in body.email (webhook structure)\nconst emailData = input.body?.email;\n\nif (!emailData || typeof emailData !== 'object') {\n  throw new Error('Invalid input: email is missing or not an object');\n}\n\n// Normalize to workflow contract: { email: {...} }\nreturn [{\n  json: {\n    email: emailData\n  }\n}];\n"
      },
      "id": "89cd2d89-838d-c243-47ed-b4721026fbac",
      "name": "ğŸ“§ Prepare Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        14760,
        5680
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.email.attachments !== undefined && Array.isArray($json.email.attachments) && $json.email.attachments.length > 0 }}",
              "value2": true
            }
          ]
        }
      },
      "id": "d696cb41-2034-01a0-4c3a-aa3db43338d6",
      "name": "ğŸ“ Has Attachments?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        15060,
        5680
      ]
    },
    {
      "parameters": {
        "jsCode": "// Save email data before splitting attachments\nconst input = $input.item.json;\nconst email = input.email;\n\nif (!email) {\n  console.warn('No email data found in input:', Object.keys(input));\n  // Return input as-is to prevent n8n from stopping\n  return [{\n    json: input\n  }];\n}\n\n// Ensure email object has attachments array (even if empty)\nconst emailWithAttachments = {\n  ...email,\n  attachments: email.attachments || []\n};\n\nreturn [{\n  json: {\n    email: emailWithAttachments,\n    emailData: emailWithAttachments // Store for later merge\n  }\n}];\n"
      },
      "id": "f9602cf0-9d3a-ef82-46c2-aa2ecdf988dc",
      "name": "ğŸ’¾ Save Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15360,
        5880
      ]
    },
    {
      "parameters": {
        "jsCode": "// Filter attachments based on group rules\n// Supports multiple groups with different attachment rules\n// Also extracts images from HTML and adds them as attachments\nconst item = $input.item;\nconst email = item.json.email || {};\nconst group = email.group || email.recipients?.[0] || 'default';\nconst allAttachments = email.attachments || [];\n\n// Define attachment rules per group\n// 'all' = all attachments, [1,4,6] = specific attachment IDs/indices\nconst attachmentRules = {\n  'vip': [1, 4, 6],\n  'test': 'all',\n  'pa.boe': [1]\n};\n\nconst rule = attachmentRules[group];\nlet filteredAttachments = [];\n\nif (rule === 'all') {\n  // Include all attachments\n  filteredAttachments = allAttachments;\n} else if (Array.isArray(rule)) {\n  // Filter by attachment IDs or indices\n  filteredAttachments = allAttachments.filter((att, index) => {\n    // Support both explicit IDs and index-based (1-based)\n    const attId = att.id || (index + 1);\n    return rule.includes(attId) || rule.includes(index + 1);\n  });\n} else {\n  // No rule found, use all attachments as fallback\n  filteredAttachments = allAttachments;\n}\n\n// Extract images from HTML and add them as attachments\n// Images need to be downloaded and embedded as CID attachments\nconst html = email.html || '';\nconst imageUrls = [];\nconst imageRegex = /<img[^>]+src=[\"']([^\"']+)[\"'][^>]*>/gi;\nlet match;\n\nwhile ((match = imageRegex.exec(html)) !== null) {\n  const imageUrl = match[1];\n  // Only add if it's a URL (not already a CID reference)\n  if (imageUrl && !imageUrl.startsWith('cid:') && !imageUrl.startsWith('data:')) {\n    // Extract filename from URL\n    const urlParts = imageUrl.split('/');\n    const filename = urlParts[urlParts.length - 1].split('?')[0]; // Remove query params\n    \n    // Check if image is already in attachments\n    const isAlreadyAttached = filteredAttachments.some(att => \n      att.url === imageUrl || att.filename === filename\n    );\n    \n    if (!isAlreadyAttached) {\n      imageUrls.push({\n        url: imageUrl,\n        filename: filename,\n        contentType: filename.match(/\\.(jpg|jpeg)$/i) ? 'image/jpeg' : \n                     filename.match(/\\.png$/i) ? 'image/png' : \n                     filename.match(/\\.gif$/i) ? 'image/gif' : 'image/jpeg',\n        _isImage: true // Flag to identify images for CID replacement\n      });\n    }\n  }\n}\n\n// Combine filtered attachments with extracted images\nconst allAttachmentsWithImages = [...filteredAttachments, ...imageUrls];\n\n// No need to embed metadata anymore - Loop node will preserve it\nconst attachmentsWithMetadata = allAttachmentsWithImages;\n\n// Return item with filtered attachments (each containing email metadata)\nreturn [{\n  json: {\n    ...item.json,\n    email: {\n      ...email,\n      attachments: attachmentsWithMetadata,\n      group: group\n    }\n  },\n  binary: item.binary || {}\n}];\n"
      },
      "id": "d33f59b4-0f75-b775-4148-8a6d928c0b96",
      "name": "ğŸ” Filter Attachments per Group",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15660,
        5880
      ]
    },
    {
      "parameters": {
        "jsCode": "// Loop over attachments and create one item per attachment\n// This replaces the Split Out node - simpler and more reliable\nconst item = $input.item;\nconst email = item.json.email || {};\nconst attachments = email.attachments || [];\n\n// Create one item per attachment with email metadata preserved\nconst items = attachments.map(attachment => ({\n  json: {\n    email: {\n      subject: email.subject,\n      html: email.html,\n      recipients: email.recipients,\n      group: email.group,\n      templateId: email.templateId,\n      templateName: email.templateName\n    },\n    url: attachment.url,\n    filename: attachment.filename,\n    contentType: attachment.contentType,\n    _isImage: attachment._isImage || false\n  },\n  binary: {}\n}));\n\nreturn items;\n"
      },
      "id": "516fc70e-d8b2-1794-4694-a2dd995e378c",
      "name": "ğŸ”„ Loop Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15960,
        5880
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.url }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        },
        "authentication": "none"
      },
      "id": "247e6ba9-2a7e-e8ce-4a2b-ba9071fb24a6",
      "name": "â¬‡ï¸ Download Attachment",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16560,
        5880
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge all attachment items into one item\n// Combines all binary data from multiple items into a single item\n// Binary data will be named: data, data_1, data_2, etc. (n8n default behavior)\n// Also replaces image URLs in HTML with CID references\n// All items have the same email metadata, so we use the first item's metadata\n\nconst items = $input.all();\n\nif (items.length === 0) {\n  return [];\n}\n\n// Use first item's email metadata (all items have the same metadata)\nconst firstItem = items[0];\nconst emailMetadata = firstItem.json.email || {};\nlet html = emailMetadata.html || '';\n\n// Collect all binary data from all items and build filename mapping\n// n8n automatically names them: data, data_1, data_2, etc. when merged\nconst combinedBinary = {};\nconst filenames = new Set(); // Track all filenames for CID replacement\n\nitems.forEach((item, index) => {\n  if (item.binary && item.binary.data) {\n    const binaryKey = index === 0 ? 'data' : `data_${index}`;\n    \n    // Get filename from attachment data\n    const attachmentFilename = item.json.filename || \n                               (item.binary.data.fileName || \n                                item.binary.data.name || \n                                `attachment_${index}`);\n    \n    // Extract base filename (without path/query params)\n    const baseFilename = attachmentFilename.split('/').pop().split('?')[0];\n    \n    // Create new binary object with fileName set (for CID matching)\n    // n8n's Email Send Node matches CID with fileName from binary metadata\n    combinedBinary[binaryKey] = {\n      ...item.binary.data,\n      fileName: baseFilename,  // Set fileName for CID matching\n      name: baseFilename       // Also set name as fallback\n    };\n    \n    if (attachmentFilename) {\n      filenames.add(attachmentFilename);\n    }\n  }\n});\n\n// Replace image URLs in HTML with CID references\n// Strategy: Extract filename from URL and replace with cid:filename\n// This works even if URLs differ (localhost vs IP address)\nfilenames.forEach(filename => {\n  // Extract base filename (without path/query params)\n  const baseFilename = filename.split('/').pop().split('?')[0];\n  \n  // Match any URL containing this filename (works with localhost, IP, etc.)\n  // Pattern: <img src=\".../filename.jpg\" ...>\n  // Replace with: <img src=\"cid:filename.jpg\" ...>\n  const regex = new RegExp(\n    `(<img[^>]+src=[\"'])([^\"']*${baseFilename.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}[^\"']*)([\"'][^>]*>)`,\n    'gi'\n  );\n  \n  html = html.replace(regex, `$1cid:${baseFilename}$3`);\n});\n\n// Update email metadata with modified HTML\nconst updatedEmailMetadata = {\n  ...emailMetadata,\n  html: html\n};\n\n// Create attachments array for Email Send Node\n// n8n Email Send Node can use binaryProperty OR attachments array\n// We provide both: binary data AND attachments array with binary property names\nconst attachmentKeys = Object.keys(combinedBinary).filter(k => k.startsWith('data'));\nconst attachmentsArray = attachmentKeys.map(key => {\n  const binary = combinedBinary[key];\n  return {\n    binaryProperty: key,\n    fileName: binary.fileName || binary.name || `attachment_${key}`\n  };\n});\n\n// Return single item with all binaries, updated HTML, and attachments array\nreturn [{\n  json: {\n    email: updatedEmailMetadata,\n    // Provide attachments array for Email Send Node\n    _attachments: attachmentsArray\n  },\n  binary: combinedBinary\n}];\n"
      },
      "id": "35cafa04-152e-da45-4e47-82339dc8f457",
      "name": "ğŸ”— Merge Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16860,
        5880
      ]
    },
    {
      "parameters": {
        "fromEmail": "noreply@eventpromoter.com",
        "toEmail": "={{ $json.email.recipients || $json.email.group || 'user@example.com' }}",
        "subject": "={{ $json.email.subject }}",
        "html": "={{ $json.email.html }}",
        "attachments": "",
        "options": {
          "attachments": {
            "binaryProperty": {
              "__expression": "={{ Object.keys($binary).filter(k => k.startsWith('data')).join(',') || 'data' }}"
            }
          }
        }
      },
      "id": "759aad6f-89e1-c521-4728-9c3c10aa5117",
      "name": "ğŸ“§ Send Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        17160,
        5880
      ]
    },
    {
      "parameters": {
        "fromEmail": "noreply@eventpromoter.com",
        "toEmail": "={{ $json.email.recipients || 'user@example.com' }}",
        "subject": "={{ $json.email.subject }}",
        "html": "={{ $json.email.html }}"
      },
      "id": "1bd6f8b7-c442-b4f7-4178-8be07cd237ad",
      "name": "ğŸ“§ Send Email (No Attachments)",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        15360,
        5940
      ]
    }
  ],
  "connections": {
    "ğŸ“¥ Webhook Trigger (API) - PRE-FORMATTED CONTENT": {
      "main": [
        [
          {
            "node": "ğŸ“§ Has Email Content?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Has Email Content?": {
      "main": [
        [
          {
            "node": "ğŸ“§ Prepare Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Prepare Email Data": {
      "main": [
        [
          {
            "node": "ğŸ“ Has Attachments?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ Has Attachments?": {
      "main": [
        [
          {
            "node": "ğŸ’¾ Save Email Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ“§ Send Email (No Attachments)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ’¾ Save Email Data": {
      "main": [
        [
          {
            "node": "ğŸ” Filter Attachments per Group",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Filter Attachments per Group": {
      "main": [
        [
          {
            "node": "ğŸ”„ Loop Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Loop Attachments": {
      "main": [
        [
          {
            "node": "â¬‡ï¸ Download Attachment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "â¬‡ï¸ Download Attachment": {
      "main": [
        [
          {
            "node": "ğŸ”— Merge Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”— Merge Attachments": {
      "main": [
        [
          {
            "node": "ğŸ“§ Send Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Send Email": {
      "main": [
        [
          {
            "node": "ğŸ”§ Structure Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Send Email (No Attachments)": {
      "main": [
        [
          {
            "node": "ğŸ”§ Structure Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”§ Structure Response": {
      "main": [
        [
          {
            "node": "âœ… Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "7302af2d76ff11fa25dfe4c4b676102587b05b140a7ac12e86e85bb8179e9e38"
  }
}